#!/usr/bin/env bash
##
## bash script to be used from cron to use TransIP API to perform
## automated updates of DNS-records for the external ip address of the
## host that runs the script (mimics DDNS).
## 
##  Copyright (C) 2018 Ronald van Engelen <ronalde+github@lacocina.nl>
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## The script and documentation are published at 
## https://github.com/ronalde/transip-api-ddns

## 
## - php code courtesy:
##   https://niek.jachimowski.nl/dynamic-dns-met-transip-via-de-api/
## - php-cli needs soap.so extension enabled
## - TransIP API reference:
##   https://api.transip.nl/docs/transip.nl/class-Transip_DnsEntry.html
##
## Installation:
## 1. run `make build' to download and install the php library, and
## install the settings and cron script to `./build':
##  make build
## 2. copy the settings.example template:
##  cp -av ./build/etc/transip-api-ddns/settings.example ./build/etc/transip-api-ddns/settings
## 3. modify the contents of `./build/etc/transip-api-ddns/settings'
## 4. modify the contents of the `dns_records' variable in
##    `./build/etc/cron.hourly/transip-api-ddns'
## 5. test the script and settings from the build directory (repeating
##    steps 3. and 4. until your satisfied):
##     cd build/etc/cron.hourly
##     DEBUG=true bash transip-api-ddns
## 6. install the php library and modified script and settings file:
##     sudo make install
## 7. test the working of the cron job:
##     sudo run-parts /etc/cron.hourly -v

APP_NAME="transip-api-ddns"
APP_VERSION="0.0.2"
DEBUG="${DEBUG:-}"
APP_CONF_DIR="/etc/${APP_NAME}"
APP_LOG_DIR="/var/log/${APP_NAME}"
APP_DB_DIR="/etc/${APP_NAME}"
APP_BUILD_DIR="build"
if [[ ${DEBUG} ]]; then
    APP_CONF_DIR="${APP_BUILD_DIR}${APP_CONF_DIR}"
    APP_LOG_DIR="${APP_BUILD_DIR}${APP_LOG_DIR}"
    APP_DB_DIR="${APP_BUILD_DIR}${APP_DB_DIR}"
fi

APP_LOG_FILE="${APP_LOG_DIR}/$(date +"%Y-%m-%d")-${APP_NAME}.log"
APP_CONF_FILE="${APP_CONF_DIR}/settings"
APP_DB_FILE="${APP_CONF_DIR}/db.dns"

MAX_RIP_RETRIES=3
RIP_RETRY_TIMEOUT=10


function do_log() {
    ## print to stderr or if ${APP_LOG_FILE} is accessible to stdout
    ## and append to log file
    msgtype="$1"
    msgtxt="$2"
    msgdate="$(date +"%Y-%m-%d %H:%m:%S")"
    printf -v msg "%s %-8s %s\n" \
	   "${msgdate}" "${msgtype}:"  "${msgtxt}"
    if [[ -w "${APP_LOG_FILE}" ]]; then
	 printf "%s" "${msg}" | tee -a "${APP_LOG_FILE}"
    else
	printf 1>&2 "%s" "${msg}"
    fi
}

function get_current_rip() {
    ## return the current remote ip address
    counter="${1:-0}"
    ((counter++))
    if (( counter < MAX_RIP_RETRIES )); then
	CURRENT_RIP="$(curl "${CONF_REMOTEIP_URL}" 2>/dev/null)"
	if [[ "${CURRENT_RIP}x" == "x" ]]; then
	    sleep "${RIP_RETRY_TIMEOUT}"
	    ret_current_rip "${counter}"
	fi
    fi
    if  [[ "${CURRENT_RIP}x" == "x" ]]; then
	do_log "error" "unable to get current remote ip address using url \`${CONF_REMOTEIP_URL}'." 
	return 1
    else
	do_log  "info" "current remote ip address: \`${CURRENT_RIP}'."
    fi 
}

function create_php_array() {
    ## construct and return the php code to construct valid TransIP
    ## API DNSRecord code
    readarray a_dns_records <<< "${dns_records}"
    #declare -p a_dns_records 1>&2 
    printf "%s" "${a_dns_records[@]}"
}


function make_log_dir() {
    ## create the log dir
    if mkdir -p "${APP_LOG_DIR}" 2>/dev/null; then
	do_log "info"  "log dir \`${APP_LOG_DIR}' created by ${APP_NAME} (v${APP_VERSION})."
    else
	do_log "warning" "unable to create log dir \`${APP_LOG_DIR}'."
	return 1
    fi
}

function parse_dns_records() {
    ## parse the contents of the dns_records variable doing some basic
    ## checks
    do_log "info" "begin parsing records"
    dns_errors=()
    line_counter=0
    dns_records=()
    #declare -p APP_DB_FILE 1>&2
    rem_re="^#"
    ## eval each line in APP_DB_FILE, which expands the variables within
    ## and turn each line in an array containing the dns fields
    while read -r line; do
	if [[ ! "${line}" =~ ${rem_re} ]]; then
	    #declare -p line
	    t_dns_record="$(eval echo $line)"
	    while read -a dns_record; do
		((line_counter++))
		record_errors=()
		nr_fields=${#dns_record[@]}
		if (( nr_fields  < 3 )) || [[ "${dns_record}" =~ ${remark_re} ]]; then
		    if [[ "${dns_record}x" == "x" ]]; then
			printf 1>&2 "skipping line ${line_counter}: empty.\n"
		    elif [[ "${dns_record}" =~ ${remark_re} ]]; then
			printf 1>&2 "skipping line ${line_counter}: remark.\n"
		    else
			printf 1>&2 "skipping line ${line_counter} (\`${dns_record}'): not a dns record.\n"
		    fi
		else
		    #declare -p dns_record
		    record_pointer="${dns_record[0]}"
		    last_index=$(( nr_fields - 1 ))
		    if [[ "${dns_record[1]^^}" == "IN" ]]; then
			type_field_nr=2
		    else
			type_field_nr=1
		    fi
		    record_type="${dns_record[${type_field_nr}]}"
		    record_value="${dns_record[@]:$(( type_field_nr + 1 )):${last_index}}"
		    printf 1>&2 "%7s=%-40s;%7s=%-7s;%7s=%s\n" \
				"pointer" "\`${record_pointer}'" \
				"type" "\`${record_type}'" \
				"value" "\`${record_value}'"
		    case "${record_type}" in
			"") 
			    record_errors+=("type is empty") ;;
			A|AAAA|MX|CNAME|TXT)
			# type is ok
			;;
			*)
			    record_errors+=("invalid record type \`${record_type}'; should be one of 'A', 'AAAA', 'CNAME', 'TXT' or 'MX'")
		    esac
		    if [[ "${record_pointer}x" == "x" ]]; then
			record_errors+=("dns pointer is empty")
		    elif  [[ "${record_value}x" == "x" ]]; then
			record_errors+=("value for pointer \`${record_pointer}' of type \`${record_type}' is empty")
		    fi
		    if (( ${#record_errors[@]} > 0 )); then
			printf -v msg_err "%s " "${record_errors[@]}"
			# store error and keep parsing 
			dns_errors+=("- in line ${line_counter}: \`${dns_record[*]}': ${msg_err}")
		    else
			((dns_record_counter++))
			php_records+=("\$new_dnsrecords[] = new Transip_DnsEntry('${record_pointer}', ${CONF_DNS_TTL}, '${record_type}', '${record_value}');")
		    fi
		fi
	    done<<< "${t_dns_record}"
	fi
    done<"${APP_DB_FILE}"
    declare -p dns_records 1>&2
    if (( ${#dns_errors[@]} > 0 )); then
	printf -v msg_err "not updating ${dns_record_counter} valid dns records because ${#dns_errors[@]} entries where found:\n"
	printf -v err_details "%s\n" "${dns_errors[@]}"
	do_log "error" "${msg_err}${err_details}"
	return 1
    else
	do_log "info" "done parsing ${dns_record_counter} valid dns records."
    fi
}

function save_php() {
    ## save the generated php code to review and debug it
    ## NOTE: the code contains your private TransIP API key, so be
    ##       sure to remvoe the file afterwards
    tempfile="$(mktemp /tmp/${APP_NAME}.XXXXX.php)"
    printf "%s\n" "${php_code}" > "${tempfile}"
    printf 1>&2 "debugging enabled: generated php code saved in:\n%s\n" \
		"${tempfile}"
}

## main 
CURRENT_RIP=""
dns_record_counter=0
php_records=()
a_dns_records=()
remark_re="^([#;]).*"
type_re="^(TXT|AAAA|A|CNAME|MX)$"

if [[ ! -d "${APP_LOG_DIR}" ]]; then
    make_log_dir
fi

if [[ ! -w "${APP_LOG_FILE}" ]]; then
    do_log "warning" "unable to write to log file \`${APP_LOG_FILE}'."
else
    do_log "info" "log file \`${APP_LOG_FILE}' created by ${APP_NAME} (v${APP_VERSION})."  
fi

if [[ ! -f "${APP_CONF_FILE}" ]]; then
    do_log "error" "settings file \`${APP_CONF_FILE}' not found."
    exit 1
else
    if source "${APP_CONF_FILE}"; then
	do_log  "info" "settings from \`${APP_CONF_FILE}' succesfully applied."
    else
	do_log  "error" "unable to apply settings from \`${APP_CONF_FILE}'"
	exit 1
    fi
fi
## check if transip api key file is present
if [[ "${CONF_TRANSIP_API_PRIVATEKEY}x" == "x" ]]; then
    if [[ ! -f "${CONF_TRANSIP_API_PRIVATEKEY_FILE}" ]]; then
	do_log "error" "TransIP API private key file not found in \`${CONF_TRANSIP_API_PRIVATEKEY_FILE}'."
	exit 1
    else
	do_log "info" "Using TransIP API private key file \`${CONF_TRANSIP_API_PRIVATEKEY_FILE}'."
	CONF_TRANSIP_API_PRIVATEKEY="$(<"${CONF_TRANSIP_API_PRIVATEKEY_FILE}")"
    fi
else
    do_log "info" "Using TransIP API private key file defined in \`${APP_CONF_FILE}'."
fi

if [[ ! -f "${APP_DB_FILE}" ]]; then
    do_log "error" "DNS db file \`${APP_DB_FILE}' not found."
    exit 1
else
    do_log "info" "Using DNS db file \`${APP_DB_FILE}'."
fi
## get current remote ip address using url configured in settings file
get_current_rip || exit 1

## parse the records
parse_dns_records

## store the generated php array code 
printf -v php_records "%s\n" "${php_records[@]}"

## check if api library files are available
if [[ ! -f "${CONF_TRANSIP_API_LIB_PATH}" ]]; then
    do_log "error" "TransIP API php library file not found in \`${CONF_TRANSIP_API_LIB_PATH}'."
else
    do_log "info" "TransIP API php library file found in \`${CONF_TRANSIP_API_LIB_PATH}'."
fi

## construct the complete php script, inserting the php array
## definition created above
php_code="
<?php
require_once('${CONF_TRANSIP_API_LIB_PATH}');
// connect with transip api
Transip_ApiSettings::\$login='${CONF_TRANSIP_API_USERNAME}';
Transip_ApiSettings::\$privateKey='${CONF_TRANSIP_API_PRIVATEKEY}';
try {
    \$new_dnsrecords = array();
    // start inserted by bash
    ${php_records}     
    // end inserted by bash   
    // save live
    Transip_DomainService::setDnsEntries('${CONF_DNS_DOMAIN}', \$new_dnsrecords);
    print 'entries saved successfully to TransIP';
    exit();
}
catch(SoapFault \$f) {
    \$msg = 'SOAP ERROR: dns not updated: ' . \$f->getMessage();
    return \$msg;
}
?>
"

## check if api library files are available
if [[ ! -f "${CONF_TRANSIP_API_LIB_PATH}" ]]; then
    ## if DEBUG is non-nill save the generated php code to a temporary file
    if [[ ${DEBUG} ]]; then
	save_php
    fi
    do_log "error" "\`${CONF_TRANSIP_API_LIB_FILE}' not found in \`${CONF_TRANSIP_API_LIB_DIR}'; TransIP API php library not installed."
else
    ## if DEBUG is non-nill save the generated php code to a temporary file
    ## otherwise execute the php code
    if [[ ${DEBUG} ]]; then
	save_php
    else
	php_out="$(php <<< "${php_code}" 2>&1)"
	php_res="$?"
	if [[ ${php_res} -ne 0 ]]; then
	    do_log "error" "error saving dns records to TransIP: php returned \`${php_res}': \`${php_out}'."
	    exit 1
	else
	    do_log "info" "done saving ${dns_record_counter} dns records to TransIP using php."
	fi
    fi
fi
